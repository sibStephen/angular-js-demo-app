{
  "version": 3,
  "file": "app.js",
  "sources": [
    "src/app.js",
    "src/directives/form-helpers.js",
    "src/error/error.js",
    "src/grandfather.js",
    "src/home/home.js",
    "src/login-service.js",
    "src/mockhttp.js",
    "src/pages/pages.js",
    "src/register/register.js",
    "src/routing-config.js"
  ],
  "names": [],
  "mappings": "AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACvEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;AC5MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;AC3KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A",
  "sourcesContent": [
    "angular.module('angular-login', [\n  // login service\n  'loginService',\n  'angular-login.mock',\n  'angular-login.directives',\n  // different app sections\n  'angular-login.home',\n  'angular-login.pages',\n  'angular-login.register',\n  'angular-login.error',\n  // components\n  'ngAnimate'\n])\n.config(function ($urlRouterProvider) {\n  $urlRouterProvider.otherwise('/');\n})\n.run(function ($rootScope, $window) {\n  // google analytics\n  $rootScope.$on('$stateChangeSuccess', function (event, toState, toParams) {\n    var realURL = toState.url;\n    if (!!$window.ga) {\n      // resolves variables inside urls, ex: /error/:error in /error/unauthorized\n      for (var v in toParams) {\n        realURL = realURL.replace(':' + v, toParams[v]);\n      }\n      $window.ga('send', 'pageview', realURL);\n    }\n  });\n  /**\n   * $rootScope.doingResolve is a flag useful to display a spinner on changing states.\n   * Some states may require remote data so it will take awhile to load.\n   */\n  var resolveDone = function () { $rootScope.doingResolve = false; };\n  $rootScope.doingResolve = false;\n\n  $rootScope.$on('$stateChangeStart', function () {\n    $rootScope.doingResolve = true;\n  });\n  $rootScope.$on('$stateChangeSuccess', resolveDone);\n  $rootScope.$on('$stateChangeError', resolveDone);\n  $rootScope.$on('$statePermissionError', resolveDone);\n})\n.controller('BodyController', function ($scope, $state, $stateParams, loginService, $http, $timeout) {\n  // Expose $state and $stateParams to the <body> tag\n  $scope.$state = $state;\n  $scope.$stateParams = $stateParams;\n\n  // loginService exposed and a new Object containing login user/pwd\n  $scope.ls = loginService;\n  $scope.login = {\n    working: false,\n    wrong: false\n  };\n  $scope.loginMe = function () {\n    // setup promise, and 'working' flag\n    var loginPromise = $http.post('/login', $scope.login);\n    $scope.login.working = true;\n    $scope.login.wrong = false;\n\n    loginService.loginUser(loginPromise);\n    loginPromise.error(function () {\n      $scope.login.wrong = true;\n      $timeout(function () { $scope.login.wrong = false; }, 8000);\n    });\n    loginPromise.finally(function () {\n      $scope.login.working = false;\n    });\n  };\n  $scope.logoutMe = function () {\n    loginService.logoutUser($http.get('/logout'));\n  };\n});\n",
    "angular.module('angular-login.directives', [])\n/**\n * Simple directive to check password equality\n *\n * usage:\n * <input type=\"password\" ng-model=\"password\" password-match=\"password2\">\n * <input type=\"password\" ng-model=\"password2\">\n */\n.directive('passwordMatch', function () {\n  return {\n    restrict: 'A',\n    scope: false,\n    require: 'ngModel',\n    link: function (scope, elem, attrs, controller) {\n      var checker = function () {\n        // get the value of the first password\n        var pwd = scope.$eval(attrs.ngModel);\n        // get the value of the other password\n        var pwd2 = scope.$eval(attrs.passwordMatch);\n        return pwd === pwd2;\n      };\n      scope.$watch(checker, function (pwdMatch) {\n        controller.$setValidity('match', pwdMatch);\n      });\n    }\n  };\n})\n/**\n * Directive to manage valid/invalid states of remote-validated Data.\n * It stores an internal array of values declared invalid by the server.\n * Generates the form error specified in case the user re-types the same invalid values,\n * clears the errors in case the user changes the ngModel.\n *\n * usage:\n * <input type=\"email\" ng-model=\"email\" remote-validated=\"used\">\n *\n * NOTE: Your controllers have to make the field invalid in case *your* server says so.\n */\n.directive('remoteValidated', function () {\n  return {\n    restrict: 'A',\n    scope: false,\n    require: 'ngModel',\n    link: function (scope, elem, attrs, controller) {\n      var invalidItems = [];\n      scope.$watch(attrs.ngModel, function (newValue, oldValue) {\n        if (newValue) {\n          // Check the array of already-bad items\n          if (invalidItems.indexOf(newValue) !== -1) {\n            return controller.$setValidity(attrs.remoteValidated, false);\n          }\n          // When the model changes, it checks if the previous value was\n          // triggering the error from server-side\n          if (controller.$error[attrs.remoteValidated]) {\n            invalidItems.push(oldValue);\n          }\n          controller.$setValidity(attrs.remoteValidated, true);\n        }\n      });\n    }\n  };\n});\n",
    "angular.module('angular-login.error', ['angular-login.grandfather'])\n.config(function ($stateProvider) {\n  $stateProvider\n    .state('app.error', {\n      url: '/error/:error',\n      templateUrl: 'error/error.tpl.html',\n      accessLevel: accessLevels.public\n    });\n});\n",
    "angular.module('angular-login.grandfather', ['ui.router', 'templates-app'])\n.config(function ($stateProvider) {\n  $stateProvider\n    .state('app', {\n      abstract: true,\n      template: '<ui-view></ui-view>',\n      resolve: {\n        'login': function (loginService, $q, $http) {\n          var roleDefined = $q.defer();\n\n          /**\n           * In case there is a pendingStateChange means the user requested a $state,\n           * but we don't know yet user's userRole.\n           *\n           * Calling resolvePendingState makes the loginService retrieve his userRole remotely.\n           */\n          if (loginService.pendingStateChange) {\n            return loginService.resolvePendingState($http.get('/user'));\n          } else {\n            roleDefined.resolve();\n          }\n          return roleDefined.promise;\n        }\n      }\n    });\n});\n",
    "angular.module('angular-login.home', ['angular-login.grandfather'])\n.config(function ($stateProvider) {\n  $stateProvider\n    .state('app.home', {\n      url: '/',\n      templateUrl: 'home/home.tpl.html',\n      controller: 'HomeController'\n    });\n})\n.controller('HomeController', function ($scope) {\n  $scope.users = angular.fromJson(localStorage.getItem('userStorage'));\n});\n",
    "angular.module('loginService', ['ui.router'])\n.provider('loginService', function () {\n  var userToken = localStorage.getItem('userToken'),\n      errorState = 'app.error',\n      logoutState = 'app.home';\n\n  this.$get = function ($rootScope, $http, $q, $state) {\n\n    /**\n     * Low-level, private functions.\n     */\n    var setHeaders = function (token) {\n      if (!token) {\n        delete $http.defaults.headers.common['X-Token'];\n        return;\n      }\n      $http.defaults.headers.common['X-Token'] = token.toString();\n    };\n\n    var setToken = function (token) {\n      if (!token) {\n        localStorage.removeItem('userToken');\n      } else {\n        localStorage.setItem('userToken', token);\n      }\n      setHeaders(token);\n    };\n\n    var getLoginData = function () {\n      if (userToken) {\n        setHeaders(userToken);\n      } else {\n        wrappedService.userRole = userRoles.public;\n        wrappedService.isLogged = false;\n        wrappedService.doneLoading = true;\n      }\n    };\n\n    var managePermissions = function () {\n      // Register routing function.\n      $rootScope.$on('$stateChangeStart', function (event, to, toParams, from, fromParams) {\n\n        /**\n         * $stateChangeStart is a synchronous check to the accessLevels property\n         * if it's not set, it will setup a pendingStateChange and will let\n         * the grandfather resolve do his job.\n         *\n         * In short:\n         * If accessLevels is still undefined, it let the user change the state.\n         * Grandfather.resolve will either let the user in or reject the promise later!\n         */\n        if (wrappedService.userRole === null) {\n          wrappedService.doneLoading = false;\n          wrappedService.pendingStateChange = {\n            to: to,\n            toParams: toParams\n          };\n          return;\n        }\n\n        // if the state has undefined accessLevel, anyone can access it.\n        // NOTE: if `wrappedService.userRole === undefined` means the service still doesn't know the user role,\n        // we need to rely on grandfather resolve, so we let the stateChange success, for now.\n        if (to.accessLevel === undefined || to.accessLevel.bitMask & wrappedService.userRole.bitMask) {\n          angular.noop(); // requested state can be transitioned to.\n        } else {\n          event.preventDefault();\n          $rootScope.$emit('$statePermissionError');\n          $state.go(errorState, { error: 'unauthorized' }, { location: false, inherit: false });\n        }\n      });\n\n      /**\n       * Gets triggered when a resolve isn't fulfilled\n       * NOTE: when the user doesn't have required permissions for a state, this event\n       *       it's not triggered.\n       *\n       * In order to redirect to the desired state, the $http status code gets parsed.\n       * If it's an HTTP code (ex: 403), could be prefixed with a string (ex: resolvename403),\n       * to handle same status codes for different resolve(s).\n       * This is defined inside $state.redirectMap.\n       */\n      $rootScope.$on('$stateChangeError', function (event, to, toParams, from, fromParams, error) {\n        /**\n         * This is a very clever way to implement failure redirection.\n         * You can use the value of redirectMap, based on the value of the rejection\n         * So you can setup DIFFERENT redirections based on different promise errors.\n         */\n        var errorObj, redirectObj;\n        // in case the promise given to resolve function is an $http request\n        // the error is a object containing the error and additional informations\n        error = (typeof error === 'object') ? error.status.toString() : error;\n        // in case of a random 4xx/5xx status code from server, user gets loggedout\n        // otherwise it *might* forever loop (look call diagram)\n        if (/^[45]\\d{2}$/.test(error)) {\n          wrappedService.logoutUser();\n        }\n        /**\n         * Generic redirect handling.\n         * If a state transition has been prevented and it's not one of the 2 above errors, means it's a\n         * custom error in your application.\n         *\n         * redirectMap should be defined in the $state(s) that can generate transition errors.\n         */\n        if (angular.isDefined(to.redirectMap) && angular.isDefined(to.redirectMap[error])) {\n          if (typeof to.redirectMap[error] === 'string') {\n            return $state.go(to.redirectMap[error], { error: error }, { location: false, inherit: false });\n          } else if (typeof to.redirectMap[error] === 'object') {\n            redirectObj = to.redirectMap[error];\n            return $state.go(redirectObj.state, { error: redirectObj.prefix + error }, { location: false, inherit: false });\n          }\n        }\n        return $state.go(errorState, { error: error }, { location: false, inherit: false });\n      });\n    };\n\n    /**\n     * High level, public methods\n     */\n    var wrappedService = {\n      loginHandler: function (user, status, headers, config) {\n        /**\n         * Custom logic to manually set userRole goes here\n         *\n         * Commented example shows an userObj coming with a 'completed'\n         * property defining if the user has completed his registration process,\n         * validating his/her email or not.\n         *\n         * EXAMPLE:\n         * if (user.hasValidatedEmail) {\n         *   wrappedService.userRole = userRoles.registered;\n         * } else {\n         *   wrappedService.userRole = userRoles.invalidEmail;\n         *   $state.go('app.nagscreen');\n         * }\n         */\n        // setup token\n        setToken(user.token);\n        // update user\n        angular.extend(wrappedService.user, user);\n        // flag true on isLogged\n        wrappedService.isLogged = true;\n        // update userRole\n        wrappedService.userRole = user.userRole;\n        return user;\n      },\n      loginUser: function (httpPromise) {\n        httpPromise.success(this.loginHandler);\n      },\n      logoutUser: function (httpPromise) {\n        /**\n         * De-registers the userToken remotely\n         * then clears the loginService as it was on startup\n         */\n        setToken(null);\n        this.userRole = userRoles.public;\n        this.user = {};\n        this.isLogged = false;\n        $state.go(logoutState);\n      },\n      resolvePendingState: function (httpPromise) {\n        var checkUser = $q.defer(),\n            self = this,\n            pendingState = self.pendingStateChange;\n\n        // When the $http is done, we register the http result into loginHandler, `data` parameter goes into loginService.loginHandler\n        httpPromise.success(self.loginHandler);\n\n        httpPromise.then(\n          function success(httpObj) {\n            self.doneLoading = true;\n            // duplicated logic from $stateChangeStart, slightly different, now we surely have the userRole informations.\n            if (pendingState.to.accessLevel === undefined || pendingState.to.accessLevel.bitMask & self.userRole.bitMask) {\n              checkUser.resolve();\n            } else {\n              checkUser.reject('unauthorized');\n            }\n          },\n          function reject(httpObj) {\n            checkUser.reject(httpObj.status.toString());\n          }\n        );\n        /**\n         * I setted up the state change inside the promises success/error,\n         * so i can safely assign pendingStateChange back to null.\n         */\n        self.pendingStateChange = null;\n        return checkUser.promise;\n      },\n      /**\n       * Public properties\n       */\n      userRole: null,\n      user: {},\n      isLogged: null,\n      pendingStateChange: null,\n      doneLoading: null\n    };\n\n    getLoginData();\n    managePermissions();\n\n    return wrappedService;\n  };\n});\n",
    "/* jshint -W084 */\nangular.module('angular-login.mock', ['ngMockE2E'])\n.factory('delayHTTP', function ($q, $timeout) {\n  return {\n    request: function (request) {\n      var delayedResponse = $q.defer();\n      $timeout(function () {\n        delayedResponse.resolve(request);\n      }, 700);\n      return delayedResponse.promise;\n    },\n    response: function (response) {\n      var deferResponse = $q.defer();\n\n      if (response.config.timeout && response.config.timeout.then) {\n        response.config.timeout.then(function () {\n          deferResponse.reject();\n        });\n      } else {\n        deferResponse.resolve(response);\n      }\n\n      return $timeout(function () {\n        deferResponse.resolve(response);\n        return deferResponse.promise;\n      });\n    }\n  };\n})\n// delay HTTP\n.config(['$httpProvider', function ($httpProvider) {\n  $httpProvider.interceptors.push('delayHTTP');\n}])\n.constant('loginExampleData', {\n  version: '0.2.0'\n})\n.run(function ($httpBackend, $log, loginExampleData) {\n  var userStorage = angular.fromJson(localStorage.getItem('userStorage')),\n      emailStorage = angular.fromJson(localStorage.getItem('emailStorage')),\n      tokenStorage = angular.fromJson(localStorage.getItem('tokenStorage')) || {},\n      loginExample = angular.fromJson(localStorage.getItem('loginExample'));\n\n  // Check and corrects old localStorage values, backward-compatibility!\n  if (!loginExample || loginExample.version !== loginExampleData.version) {\n    userStorage = null;\n    tokenStorage = {};\n    localStorage.setItem('loginExample', angular.toJson(loginExampleData));\n  }\n\n  if (userStorage === null || emailStorage === null) {\n    userStorage = {\n      'johnm': { name: 'John', username: 'johnm', password: 'hello', email: 'john.dott@myemail.com', userRole: userRoles.user, tokens: [] },\n      'sandrab': { name: 'Sandra', username: 'sandrab', password: 'world', email: 'bitter.s@provider.com', userRole: userRoles.admin, tokens: [] }\n    };\n    emailStorage = {\n      'john.dott@myemail.com': 'johnm',\n      'bitter.s@provider.com': 'sandrab'\n    };\n    localStorage.setItem('userStorage', angular.toJson(userStorage));\n    localStorage.setItem('emailStorage', angular.toJson(emailStorage));\n  }\n\n  /**\n   * Generates random Token\n   */\n  var randomUUID = function () {\n    var charSet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n    var randomToken = '';\n    for (var i = 0; i < 36; i++) {\n      if (i === 8 || i === 13 || i === 18 || i === 23) {\n        randomToken += '';\n        continue;\n      }\n      var randomPoz = Math.floor(Math.random() * charSet.length);\n      randomToken += charSet.substring(randomPoz, randomPoz + 1);\n    }\n    return randomToken;\n  };\n\n  // fakeLogin\n  $httpBackend.when('POST', '/login').respond(function (method, url, data, headers) {\n    var postData = angular.fromJson(data),\n        user = userStorage[postData.username],\n        newToken,\n        tokenObj;\n    $log.info(method, '->', url);\n\n    if (angular.isDefined(user) && user.password === postData.password) {\n      newToken = randomUUID();\n      user.tokens.push(newToken);\n      tokenStorage[newToken] = postData.username;\n      localStorage.setItem('userStorage', angular.toJson(userStorage));\n      localStorage.setItem('tokenStorage', angular.toJson(tokenStorage));\n      return [200, { name: user.name, userRole: user.userRole, token: newToken }, {}];\n    } else {\n      return [401, 'wrong combination username/password', {}];\n    }\n  });\n\n  // fakeLogout\n  $httpBackend.when('GET', '/logout').respond(function (method, url, data, headers) {\n    var queryToken, userTokens;\n    $log.info(method, '->', url);\n\n    if (queryToken = headers['X-Token']) {\n      if (angular.isDefined(tokenStorage[queryToken])) {\n        userTokens = userStorage[tokenStorage[queryToken]].tokens;\n        // Update userStorage AND tokenStorage\n        userTokens.splice(userTokens.indexOf(queryToken));\n        delete tokenStorage[queryToken];\n        localStorage.setItem('userStorage', angular.toJson(userStorage));\n        localStorage.setItem('tokenStorage', angular.toJson(tokenStorage));\n        return [200, {}, {}];\n      } else {\n        return [401, 'auth token invalid or expired', {}];\n      }\n    } else {\n      return [401, 'auth token invalid or expired', {}];\n    }\n  });\n\n  // fakeUser\n  $httpBackend.when('GET', '/user').respond(function (method, url, data, headers) {\n    var queryToken, userObject;\n    $log.info(method, '->', url);\n\n    // if is present in a registered users array.\n    if (queryToken = headers['X-Token']) {\n      if (angular.isDefined(tokenStorage[queryToken])) {\n        userObject = userStorage[tokenStorage[queryToken]];\n        return [200, { token: queryToken, name: userObject.name, userRole: userObject.userRole }, {}];\n      } else {\n        return [401, 'auth token invalid or expired', {}];\n      }\n    } else {\n      return [401, 'auth token invalid or expired', {}];\n    }\n  });\n\n  // fakeRegister\n  $httpBackend.when('POST', '/user').respond(function (method, url, data, headers) {\n    var postData = angular.fromJson(data),\n        newUser,\n        errors = [];\n    $log.info(method, '->', url);\n\n    if (angular.isDefined(userStorage[postData.username])) {\n      errors.push({ field: 'username', name: 'used' });\n    }\n\n    if (angular.isDefined(emailStorage[postData.email])) {\n      errors.push({ field: 'email', name: 'used' });\n    }\n\n    if (errors.length) {\n      return [409, {\n        valid: false,\n        errors: errors\n      }, {}];\n    } else {\n      newUser = angular.extend(postData, { userRole: userRoles[postData.role], tokens: [] });\n      delete newUser.role;\n\n      userStorage[newUser.username] = newUser;\n      emailStorage[newUser.email] = newUser.username;\n      localStorage.setItem('userStorage', angular.toJson(userStorage));\n      localStorage.setItem('emailStorage', angular.toJson(emailStorage));\n      return [201, { valid: true, creationDate: Date.now() }, {}];\n    }\n  });\n\n});\n",
    "angular.module('angular-login.pages', ['angular-login.grandfather'])\n.config(function ($stateProvider) {\n  $stateProvider\n    .state('app.admin', {\n      url: '/admin',\n      templateUrl: 'pages/admin.tpl.html',\n      accessLevel: accessLevels.admin\n    })\n    .state('app.user', {\n      url: '/user',\n      templateUrl: 'pages/user.tpl.html',\n      accessLevel: accessLevels.user\n    });\n});\n",
    "angular.module('angular-login.register', ['angular-login.grandfather'])\n.config(function ($stateProvider) {\n  $stateProvider\n    .state('app.register', {\n      url: '/register',\n      templateUrl: 'register/register.tpl.html',\n      controller: 'RegisterController',\n      accessLevel: accessLevels.anon\n    });\n})\n.controller('RegisterController', function ($scope, $http, $timeout, $state) {\n  $scope.xhr = false;\n  $scope.redirect = false;\n\n  $scope.registerObj = {\n    role: 'user'\n  };\n\n  $scope.submit = function (formInstance) {\n    // xhr is departing\n    $scope.xhr = true;\n    $http.post('/user', $scope.registerObj)\n    .success(function (data, status, headers, config) {\n      console.info('post success - ', data);\n      $scope.xhr = false;\n      $scope.redirect = true;\n      $timeout(function () {\n        $state.go('app.home');\n      }, 2000);\n    })\n    .error(function (data, status, headers, config) {\n      data.errors.forEach(function (error, index, array) {\n        formInstance[error.field].$error[error.name] = true;\n      });\n      formInstance.$setPristine();\n      console.info('post error - ', data);\n      $scope.xhr = false;\n    });\n  };\n});\n",
    "/**\n * Directly from fnakstad\n * https://github.com/fnakstad/angular-client-side-auth/blob/master/client/js/routingConfig.js\n */\n\n(function (exports) {\n\n  var config = {\n\n    /* List all the roles you wish to use in the app\n    * You have a max of 31 before the bit shift pushes the accompanying integer out of\n    * the memory footprint for an integer\n    */\n    roles: [\n      'public',\n      'user',\n      'admin'\n    ],\n\n    /*\n    Build out all the access levels you want referencing the roles listed above\n    You can use the \"*\" symbol to represent access to all roles\n     */\n    accessLevels: {\n      'public' : '*',\n      'anon': ['public'],\n      'user' : ['user', 'admin'],\n      'admin': ['admin']\n    }\n\n  };\n\n  /*\n    Method to build a distinct bit mask for each role\n    It starts off with \"1\" and shifts the bit to the left for each element in the\n    roles array parameter\n   */\n  function buildRoles(roles) {\n\n    var bitMask = \"01\";\n    var userRoles = {};\n\n    for (var role in roles) {\n      var intCode = parseInt(bitMask, 2);\n      userRoles[roles[role]] = {\n        bitMask: intCode,\n        title: roles[role]\n      };\n      bitMask = (intCode << 1).toString(2);\n    }\n\n    return userRoles;\n  }\n\n  /*\n  This method builds access level bit masks based on the accessLevelDeclaration parameter which must\n  contain an array for each access level containing the allowed user roles.\n   */\n  function buildAccessLevels(accessLevelDeclarations, userRoles) {\n\n    var accessLevels = {},\n        resultBitMask,\n        role;\n    for (var level in accessLevelDeclarations) {\n\n      if (typeof accessLevelDeclarations[level] === 'string') {\n        if (accessLevelDeclarations[level] === '*') {\n\n          resultBitMask = '';\n\n          for (role in userRoles) {\n            resultBitMask += \"1\";\n          }\n          //accessLevels[level] = parseInt(resultBitMask, 2);\n          accessLevels[level] = {\n            bitMask: parseInt(resultBitMask, 2),\n            title: accessLevelDeclarations[level]\n          };\n        }\n        else {\n          console.log(\"Access Control Error: Could not parse '\" + accessLevelDeclarations[level] + \"' as access definition for level '\" + level + \"'\");\n        }\n      }\n      else {\n\n        resultBitMask = 0;\n        for (role in accessLevelDeclarations[level]) {\n          if (userRoles.hasOwnProperty(accessLevelDeclarations[level][role])) {\n            resultBitMask = resultBitMask | userRoles[accessLevelDeclarations[level][role]].bitMask;\n          }\n          else {\n            console.log(\"Access Control Error: Could not find role '\" + accessLevelDeclarations[level][role] + \"' in registered roles while building access for '\" + level + \"'\");\n          }\n        }\n        accessLevels[level] = {\n          bitMask: resultBitMask,\n          title: accessLevelDeclarations[level][role]\n        };\n      }\n    }\n\n    return accessLevels;\n  }\n\n\n  exports.userRoles = buildRoles(config.roles);\n  exports.accessLevels = buildAccessLevels(config.accessLevels, exports.userRoles);\n\n})(typeof exports === 'undefined' ? this : exports);\n"
  ]
}